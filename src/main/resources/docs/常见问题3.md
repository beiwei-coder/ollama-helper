# Java 开发中常见问题汇总
## 1. 空指针异常（NullPointerException）
   原因：尝试调用一个 null 对象的方法或访问其字段。
   示例：
   java
   String str = null;
   int len = str.length(); // 抛出 NullPointerException
   解决方法：
   使用前判断是否为 null。
   使用 Optional 类（Java 8+）避免显式判空。
## 2. 并发修改异常（ConcurrentModificationException）
   原因：在遍历集合（如 ArrayList、HashMap）的同时对其进行结构性修改。
   示例：
   java
   for (String s : list) {
   if ("bad".equals(s)) list.remove(s); // 可能抛出异常
   }
   解决方法：
   使用 Iterator.remove()。
   使用并发安全的集合（如 CopyOnWriteArrayList、ConcurrentHashMap）。
## 3. 内存泄漏（Memory Leak）
   原因：对象不再使用但未被垃圾回收，例如静态集合持有对象引用。
   典型场景：
   静态 Map 缓存未清理。
   未关闭的资源（如 InputStream、数据库连接）。
   解决方法：
   使用 try-with-resources 自动关闭资源。
   定期清理缓存，或使用弱引用（WeakHashMap）。
## 4. 字符串比较错误
   错误写法：
   ```java
   String a = new String("hello");
    String b = new String("hello");
   if (a == b) { ... } // false，比较的是引用而非内容
   ```
   正确做法：
   ```java
   if (a.equals(b)) { ... } // true
   ```

## 5. 日期时间处理混乱
   问题：使用过时的 Date / Calendar API 导致线程安全或格式问题。
   推荐方案：
   Java 8+ 使用 `java.time` 包（如 `LocalDateTime`, `ZonedDateTime`）。
   ```java
   LocalDateTime now = LocalDateTime.now();
   ```

## 6. 泛型类型擦除导致的问题
   现象：运行时无法获取泛型具体类型。
   影响：不能直接实例化泛型类型（如 new T()）。
   绕过方法：
   通过传入 Class<T> 参数。
   使用反射配合类型令牌（TypeToken，如 Gson 中的做法）。
## 7. 序列化问题
   常见错误：
   未实现 Serializable 接口却尝试序列化。
   修改类结构后反序列化失败（serialVersionUID 不匹配）。
   建议：
   显式声明 private static final long serialVersionUID = 1L;。
## 8. 类加载与 ClassNotFoundException / NoClassDefFoundError
   区别：
   ClassNotFoundException：运行时找不到类（动态加载时）。
   NoClassDefFoundError：编译时存在，运行时缺失依赖。
   排查方法：
   检查 classpath 或 Maven/Gradle 依赖。
   注意模块路径（Java 9+ 模块系统）。

## 9. 线程安全问题
   典型场景：
   多个线程同时修改共享变量（如计数器）。
   解决方案：
   使用 synchronized、ReentrantLock。
   使用线程安全类（如 AtomicInteger、ConcurrentHashMap）。

## 10. Maven/Gradle 依赖冲突
    >表现：程序行为异常，可能因不同版本的同一库共存。
    排查工具：
    Maven: mvn dependency:tree
    Gradle: ./gradlew dependencies
    解决：
    排除冲突依赖。
    统一版本（使用 <dependencyManagement> 或 resolutionStrategy）。

💡 提示：良好的编码习惯（如单元测试、静态代码分析、日志记录）可大幅减少上述问题的发生。